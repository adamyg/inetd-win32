//
//  HTTP Service example,
//  utilising https://gitlab.com/eidheim/Simple-Web-Server
//

#define USE_STANDALONE_ASIO 1
#define __STDC_LIMIT_MACROS

#if defined(_MSC_VER)
#define _SCL_SECURE_NO_WARNINGS 1
#pragma warning(disable:4244) // 'xxx': conversion from 'xxx' to 'xxx', possible loss of data
#pragma warning(disable:4503) // 'xxx': decorated name length exceeded, name was truncated)
#endif

#include <future>
#include <vector>
#include <iostream>
#include <fstream>

#if (defined(_MSC_VER) && (_MSC_VER == 1900)) || \
            defined(HAVE_EXPERIMENTAL_FILESYSTEM)
#define  _SILENCE_EXPERIMENTAL_FILESYSTEM_DEPRECATION_WARNING
#include <experimental/filesystem>
namespace filesystem = std::experimental::filesystem;
#else
#include <filesystem>
namespace filesystem = std::filesystem;
#endif

#include "../libinetd/ServiceGetOpt.h"
#include "../libinetd/SocketShare.h"

#include "http_service.h"

#define PROGNAME    "http_service"

static const char *short_options = "i:";
static struct inetd::Getopt::Option long_options[] = {
    { "usage",      inetd::Getopt::argument_none,   NULL,   1000 },
    { "ip4",        inetd::Getopt::argument_none,   NULL,   1001 },
    { "ip6",        inetd::Getopt::argument_none,   NULL,   1002 },
//  { "nowait",     inetd::Getopt::argument_none,   NULL,   1003 },
//  { "wait",       inetd::Getopt::argument_none,   NULL,   1004 },
//  { "multi",      inetd::Getopt::argument_none,   NULL,   1005 },
//  { "ssl",        inetd::Getopt::argument_none,   NULL,   1006 },
    { NULL }
};

extern void usage(const char *fmt = NULL, ...); /*no-return*/
extern int  process(SOCKET socket);

int
main(int argc, const char **argv)
{
    inetd::Getopt options(short_options, long_options, argv[0]);
    const char *basename = NULL;
    std::string msg;
    bool ip6 = false;

    while (-1 != options.shift(argc, argv, msg)) {
        switch (options.optret()) {
        case 'i':   // interface
            basename = options.optarg();
            break;
        case 1002:  // --ip4
            ip6 = false;
            break;
        case 1001:  // --ip6
            ip6 = true;
            break;
        case 1000:  // usage
            usage();
        default:    // error
            usage("%s", msg.c_str());
        }
    }

    if (NULL == basename) {
        usage("missing interface specification");
    }

    argv += options.optind();
    if (0 != (argc -= options.optind())) {
        usage("unexpected arguments");
    }

    SOCKET socket = inetd::SocketShare::GetSocket(basename, WSA_FLAG_OVERLAPPED /*asio*/);
    if (INVALID_SOCKET != socket) {
        return process(socket);
    }
}


void
usage(const char *fmt, ...)
{
    if (fmt) {
        va_list ap;
        va_start(ap, fmt);
        vfprintf(stderr, fmt, ap), fputs("\n\n", stderr);
        va_end(ap);
    }

    fprintf(stderr,
        "Usage: %s [options] -i interface\n\n", PROGNAME);
    fprintf(stderr,
        "options:\n"
        "   -i <interface>      Parent interface.\n"
        "   --ip[46]            Interface type; default ip4.\n"
//      "   --[no]wait          nowait/wait mode; default nowait.\n"
//      "   --multi             Multisocket mode.\n"
//      "   --ssl               ssl mode.\n"
//      "   --cert <cert>       server certificate.\n"
        );
    exit(3);
}


static int
process(SOCKET socket)
{
    http_service server;

    //
    // GET-example for the path /info
    // Responds with request-information
    server.resource["^/info$"]["GET"] = [](std::shared_ptr<http_service::Response> response, std::shared_ptr<http_service::Request> request) {
        std::stringstream stream;

        stream << "<h1>Request from " << request->remote_endpoint().address().to_string() << ":" << request->remote_endpoint().port() << "</h1>";
        stream << request->method << " " << request->path << " HTTP/" << request->http_version;
        stream << "<h2>Query Fields</h2>";
        auto query_fields = request->parse_query_string();
        for(auto &field : query_fields) {
            stream << field.first << ": " << field.second << "<br>";
        }
        stream << "<h2>Header Fields</h2>";
        for(auto &field : request->header) {
            stream << field.first << ": " << field.second << "<br>";
        }
        response->write(stream);
    };

    //
    // Default GET-example. If no other matches, this anonymous function will be called.
    // Will respond with content in the web/-directory, and its subdirectories.
    // Default file: index.html
    server.default_resource["GET"] = [](std::shared_ptr<http_service::Response> response, std::shared_ptr<http_service::Request> request) {
        try {
            auto web_root_path = filesystem::canonical("web");
            auto path = filesystem::canonical(web_root_path / request->path);

            // Check if path is within web_root_path
            if (std::distance(web_root_path.begin(), web_root_path.end()) > std::distance(path.begin(), path.end()) ||
                        !std::equal(web_root_path.begin(), web_root_path.end(), path.begin()))
                throw std::invalid_argument("path must be within root path");

            if (filesystem::is_directory(path)) {
                path /= "index.html";
            }

            SimpleWeb::CaseInsensitiveMultimap header;

            // Uncomment the following line to enable Cache-Control
            // header.emplace("Cache-Control", "max-age=86400");

#ifdef HAVE_OPENSSL
//          // Uncomment the following lines to enable ETag
//          {
//              std::ifstream ifs(path.string(), ifstream::in | ios::binary);
//              if (ifs) {
//                  const auto hash = SimpleWeb::Crypto::to_hex_string(SimpleWeb::Crypto::md5(ifs));
//
//                  header.emplace("ETag", "\"" + hash + "\"");
//                  auto it = request->header.find("If-None-Match");
//                  if (it != request->header.end()) {
//                      if (!it->second.empty() && it->second.compare(1, hash.size(), hash) == 0) {
//                          response->write(SimpleWeb::StatusCode::redirection_not_modified, header);
//                          return;
//                      }
//                  }
//               } else {
//                  throw std::invalid_argument("could not read file");
//              }
//          }
#endif  //HAVE_OPENSSL

            auto ifs = std::make_shared<std::ifstream>();

            ifs->open(path.string(), std::ifstream::in | std::ios::binary | std::ios::ate);
            if (*ifs) {
                const auto length = ifs->tellg();

                ifs->seekg(0, std::ios::beg);
                header.emplace("Content-Length", std::to_string(length));
                response->write(header);

                // Trick to define a recursive function within this scope (for example purposes)
                class FileServer {
                public:
                    static void read_and_send(const std::shared_ptr<http_service::Response> &response, const std::shared_ptr<std::ifstream> &ifs) {
                        // Read and send 128 KB at a time
                        static std::vector<char> buffer(128 * 1024);
                                // Safe when server is running on one thread
                        std::streamsize read_length;

                        if ((read_length = ifs->read(&buffer[0],
                                    static_cast<std::streamsize>(buffer.size())).gcount()) > 0) {
                            response->write(&buffer[0], read_length);
                            if (read_length == static_cast<std::streamsize>(buffer.size())) {
                                        response->send([response, ifs](const SimpleWeb::error_code &ec) {
                                if (! ec) {
                                    read_and_send(response, ifs);
                                } else {
                                    std::cerr << "Connection interrupted" << std::endl;
                                }});
                            }
                        }
                    }
                };

                FileServer::read_and_send(response, ifs);

            } else {
                throw std::invalid_argument("could not read file");
            }

        } catch(const std::exception &e) {
            response->write(SimpleWeb::StatusCode::client_error_bad_request, "Could not open path " + request->path + ": " + e.what());
        }
    };

    server.on_error = [](std::shared_ptr<http_service::Request> /*request*/, const SimpleWeb::error_code & /*ec*/) {
        // Handle errors here
        // Note that connection timeouts will also call this handle with ec set to SimpleWeb::errc::operation_canceled
        };

    std::cerr << socket << ": Connection open" << std::endl;
    server.start(socket);
    std::cerr << socket << ": Connection complete" << std::endl;

    return 0;
}

//end
